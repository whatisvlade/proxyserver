const express = require('express');
const cors = require('cors');
const { createProxyMiddleware } = require('http-proxy-middleware');

const app = express();
const PORT = process.env.PORT || 37699;

// Middleware
app.use(cors({
  origin: '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  credentials: true
}));

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// ===== –ó–ê–©–ò–¢–ê –û–¢ –î–í–û–ô–ù–û–ô –†–û–¢–ê–¶–ò–ò =====
const userRotationLocks = new Map();
const userLastRotation = new Map();
const ROTATION_COOLDOWN_MS = 6000; // 6 —Å–µ–∫—É–Ω–¥ –∑–∞—â–∏—Ç–∞ –æ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
const CLEANUP_INTERVAL_MS = 300000; // 5 –º–∏–Ω—É—Ç - –æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π

// –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
setInterval(() => {
  const now = Date.now();
  const cutoff = now - (ROTATION_COOLDOWN_MS * 2);
  
  for (const [user, timestamp] of userLastRotation.entries()) {
    if (timestamp < cutoff) {
      userLastRotation.delete(user);
      userRotationLocks.delete(user);
    }
  }
  
  console.log(`üßπ Cleanup: ${userLastRotation.size} users in rotation cache`);
}, CLEANUP_INTERVAL_MS);

// –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ —Ä–æ—Ç–∞—Ü–∏–∏
function checkRotationCooldown(user) {
  const now = Date.now();
  const lastRotation = userLastRotation.get(user) || 0;
  const timeSinceLastRotation = now - lastRotation;
  
  if (timeSinceLastRotation < ROTATION_COOLDOWN_MS) {
    const remainingCooldown = ROTATION_COOLDOWN_MS - timeSinceLastRotation;
    return {
      allowed: false,
      remainingMs: remainingCooldown,
      message: `Rotation cooldown active. Wait ${Math.ceil(remainingCooldown / 1000)}s`
    };
  }
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ
  if (userRotationLocks.get(user)) {
    return {
      allowed: false,
      remainingMs: 1000,
      message: 'Rotation already in progress for this user'
    };
  }
  
  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–ª–æ–∫–∏—Ä–æ–≤–∫—É
  userRotationLocks.set(user, true);
  userLastRotation.set(user, now);
  
  return { allowed: true };
}

// –§—É–Ω–∫—Ü–∏—è —Å–Ω—è—Ç–∏—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ —Ä–æ—Ç–∞—Ü–∏–∏
function releaseRotationLock(user) {
  userRotationLocks.delete(user);
}

// ===== –î–ò–ù–ê–ú–ò–ß–ï–°–ö–û–ï –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–†–û–ö–°–ò =====
// –ü—Ä–æ–∫—Å–∏ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–ª–∏ –≤–Ω–µ—à–Ω–µ–≥–æ API
let proxyList = [];
const userProxyIndex = new Map();
const userConnections = new Map();

// –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–∫—Å–∏ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
function loadProxiesFromEnv() {
  const proxiesEnv = process.env.PROXY_LIST;
  if (proxiesEnv) {
    try {
      proxyList = JSON.parse(proxiesEnv);
      console.log(`üìã Loaded ${proxyList.length} proxies from environment`);
      return true;
    } catch (error) {
      console.error('‚ùå Failed to parse PROXY_LIST from environment:', error.message);
    }
  }
  return false;
}

// –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–∫—Å–∏ –∏–∑ –≤–Ω–µ—à–Ω–µ–≥–æ API (–Ω–∞–ø—Ä–∏–º–µ—Ä, –æ—Ç Telegram –±–æ—Ç–∞)
async function loadProxiesFromAPI() {
  const apiUrl = process.env.PROXY_API_URL;
  const apiKey = process.env.PROXY_API_KEY;
  
  if (!apiUrl) {
    console.log('‚ö†Ô∏è PROXY_API_URL not configured, using empty proxy list');
    return false;
  }
  
  try {
    const fetch = (await import('node-fetch')).default;
    const response = await fetch(apiUrl, {
      headers: apiKey ? { 'Authorization': `Bearer ${apiKey}` } : {},
      timeout: 10000
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    proxyList = Array.isArray(data) ? data : data.proxies || [];
    
    console.log(`üìã Loaded ${proxyList.length} proxies from API`);
    return true;
    
  } catch (error) {
    console.error('‚ùå Failed to load proxies from API:', error.message);
    return false;
  }
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ø–∏—Å–∫–∞ –ø—Ä–æ–∫—Å–∏
async function initializeProxies() {
  console.log('üîÑ Initializing proxy list...');
  
  // –ü—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
  if (loadProxiesFromEnv()) {
    return;
  }
  
  // –ü—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑ API
  if (await loadProxiesFromAPI()) {
    return;
  }
  
  // Fallback - –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
  console.log('‚ö†Ô∏è No proxies loaded, server will work without proxy rotation');
  proxyList = [];
}

// –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø—Ä–æ–∫—Å–∏ (–∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç)
setInterval(async () => {
  console.log('üîÑ Refreshing proxy list...');
  await loadProxiesFromAPI();
}, 300000);

// API –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–∫—Å–∏ (–¥–ª—è Telegram –±–æ—Ç–∞)
app.post('/api/proxies', (req, res) => {
  const apiKey = req.headers['authorization']?.replace('Bearer ', '');
  const expectedKey = process.env.ADMIN_API_KEY;
  
  if (!expectedKey || apiKey !== expectedKey) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  const { action, proxy } = req.body;
  
  if (action === 'add' && proxy) {
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –ø—Ä–æ–∫—Å–∏
    if (!proxy.host || !proxy.port || !proxy.user || !proxy.pass) {
      return res.status(400).json({ error: 'Missing required proxy fields' });
    }
    
    proxyList.push(proxy);
    console.log(`‚ûï Added proxy: ${proxy.host}:${proxy.port}`);
    
    res.json({ 
      success: true, 
      message: 'Proxy added', 
      total: proxyList.length 
    });
    
  } else if (action === 'remove' && proxy) {
    // –£–¥–∞–ª—è–µ–º –ø—Ä–æ–∫—Å–∏
    const index = proxyList.findIndex(p => 
      p.host === proxy.host && p.port === proxy.port
    );
    
    if (index !== -1) {
      const removed = proxyList.splice(index, 1)[0];
      console.log(`‚ûñ Removed proxy: ${removed.host}:${removed.port}`);
      
      res.json({ 
        success: true, 
        message: 'Proxy removed', 
        total: proxyList.length 
      });
    } else {
      res.status(404).json({ error: 'Proxy not found' });
    }
    
  } else if (action === 'list') {
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–∫—Å–∏ (–±–µ–∑ –ø–∞—Ä–æ–ª–µ–π)
    const safeList = proxyList.map(p => ({
      host: p.host,
      port: p.port,
      user: p.user
    }));
    
    res.json({ 
      success: true, 
      proxies: safeList, 
      total: proxyList.length 
    });
    
  } else if (action === 'clear') {
    // –û—á–∏—â–∞–µ–º –≤–µ—Å—å —Å–ø–∏—Å–æ–∫
    const count = proxyList.length;
    proxyList = [];
    console.log(`üóëÔ∏è Cleared all proxies (${count} removed)`);
    
    res.json({ 
      success: true, 
      message: `Cleared ${count} proxies` 
    });
    
  } else {
    res.status(400).json({ error: 'Invalid action or missing proxy data' });
  }
});

// –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
function authenticate(authHeader) {
  if (!authHeader || !authHeader.startsWith('Basic ')) {
    return null;
  }
  
  try {
    const credentials = Buffer.from(authHeader.slice(6), 'base64').toString('utf-8');
    const [username, password] = credentials.split(':');
    
    if (username && password) {
      return username;
    }
  } catch (error) {
    console.error('Authentication error:', error.message);
  }
  
  return null;
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –ø—Ä–æ–∫—Å–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
function getCurrentProxy(user) {
  if (proxyList.length === 0) {
    return null;
  }
  
  const index = userProxyIndex.get(user) || 0;
  return proxyList[index % proxyList.length];
}

// –†–æ—Ç–∞—Ü–∏—è –ø—Ä–æ–∫—Å–∏
function rotateProxy(user) {
  if (proxyList.length === 0) {
    throw new Error('No proxies available');
  }
  
  const currentIndex = userProxyIndex.get(user) || 0;
  const newIndex = (currentIndex + 1) % proxyList.length;
  userProxyIndex.set(user, newIndex);
  
  const oldProxy = proxyList[currentIndex % proxyList.length];
  const newProxy = proxyList[newIndex];
  
  console.log(`üîÑ ROTATE ${user}: ${oldProxy.host}:${oldProxy.port} -> ${newProxy.host}:${newProxy.port} (#${newIndex + 1}/${proxyList.length}) [PROTECTED]`);
  
  return {
    old: oldProxy,
    new: newProxy,
    index: newIndex + 1,
    total: proxyList.length
  };
}

// ===== API ENDPOINTS =====

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –ø—Ä–æ–∫—Å–∏
app.get('/current', (req, res) => {
  const user = authenticate(req.headers['authorization']);
  if (!user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  const proxy = getCurrentProxy(user);
  if (!proxy) {
    return res.status(503).json({ 
      error: 'No proxies available',
      message: 'Proxy list is empty. Add proxies via API or environment variables.'
    });
  }
  
  const connections = userConnections.get(user) || [];
  
  console.log(`[SELF-API] GET /current Host:${req.get('host')} User:${user}`);
  
  res.json({
    proxy: {
      host: proxy.host,
      port: proxy.port,
      user: proxy.user
    },
    index: (userProxyIndex.get(user) || 0) + 1,
    total: proxyList.length,
    connections: connections.length,
    timestamp: new Date().toISOString()
  });
});

// –†–æ—Ç–∞—Ü–∏—è –ø—Ä–æ–∫—Å–∏ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
app.post('/rotate', (req, res) => {
  const user = authenticate(req.headers['authorization']);
  if (!user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  console.log(`[SELF-API] POST /rotate Host:${req.get('host')} User:${user}`);
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø—Ä–æ–∫—Å–∏
  if (proxyList.length === 0) {
    return res.status(503).json({
      error: 'No proxies available',
      message: 'Proxy list is empty. Add proxies via API or environment variables.'
    });
  }
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—É–ª–¥–∞—É–Ω —Ä–æ—Ç–∞—Ü–∏–∏
  const cooldownCheck = checkRotationCooldown(user);
  if (!cooldownCheck.allowed) {
    console.log(`‚õî ROTATION BLOCKED for ${user}: ${cooldownCheck.message}`);
    return res.status(429).json({
      error: 'Rotation cooldown active',
      message: cooldownCheck.message,
      remainingMs: cooldownCheck.remainingMs,
      cooldownSeconds: Math.ceil(cooldownCheck.remainingMs / 1000)
    });
  }
  
  try {
    const rotation = rotateProxy(user);
    
    // –ò–º–∏—Ç–∏—Ä—É–µ–º –Ω–µ–±–æ–ª—å—à—É—é –∑–∞–¥–µ—Ä–∂–∫—É –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç–∏
    setTimeout(() => {
      releaseRotationLock(user);
    }, 1000);
    
    res.json({
      success: true,
      rotation: {
        from: `${rotation.old.host}:${rotation.old.port}`,
        to: `${rotation.new.host}:${rotation.new.port}`,
        index: rotation.index,
        total: rotation.total
      },
      proxy: {
        host: rotation.new.host,
        port: rotation.new.port,
        user: rotation.new.user
      },
      timestamp: new Date().toISOString(),
      cooldownMs: ROTATION_COOLDOWN_MS
    });
    
  } catch (error) {
    releaseRotationLock(user);
    console.error(`‚ùå Rotation error for ${user}:`, error.message);
    res.status(500).json({ 
      error: 'Rotation failed', 
      message: error.message 
    });
  }
});

// –°—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–µ—Ä–∞
app.get('/status', (req, res) => {
  const user = authenticate(req.headers['authorization']);
  if (!user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  const proxy = getCurrentProxy(user);
  const connections = userConnections.get(user) || [];
  const lastRotation = userLastRotation.get(user);
  const rotationLocked = userRotationLocks.get(user) || false;
  
  res.json({
    status: 'online',
    user: user,
    proxy: proxy ? {
      host: proxy.host,
      port: proxy.port,
      user: proxy.user,
      index: (userProxyIndex.get(user) || 0) + 1,
      total: proxyList.length
    } : null,
    connections: connections.length,
    rotation: {
      locked: rotationLocked,
      lastRotation: lastRotation ? new Date(lastRotation).toISOString() : null,
      cooldownMs: ROTATION_COOLDOWN_MS,
      canRotate: lastRotation ? (Date.now() - lastRotation >= ROTATION_COOLDOWN_MS) : true
    },
    server: {
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      activeUsers: userLastRotation.size,
      totalProxies: proxyList.length
    },
    timestamp: new Date().toISOString()
  });
});

// –°–±—Ä–æ—Å –∫—É–ª–¥–∞—É–Ω–∞ (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
app.post('/reset-cooldown', (req, res) => {
  const user = authenticate(req.headers['authorization']);
  if (!user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  userLastRotation.delete(user);
  userRotationLocks.delete(user);
  
  console.log(`üîÑ Cooldown reset for user: ${user}`);
  
  res.json({
    success: true,
    message: 'Rotation cooldown reset',
    user: user,
    timestamp: new Date().toISOString()
  });
});

// ===== PROXY MIDDLEWARE =====
const proxyMiddleware = createProxyMiddleware({
  target: 'http://example.com', // –ë—É–¥–µ—Ç –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω –≤ router
  changeOrigin: true,
  followRedirects: true,
  secure: false,
  timeout: 30000,
  proxyTimeout: 30000,
  
  router: (req) => {
    const user = authenticate(req.headers['authorization']);
    if (!user) return 'http://example.com';
    
    const proxy = getCurrentProxy(user);
    if (!proxy) return 'http://example.com';
    
    const target = `http://${proxy.host}:${proxy.port}`;
    
    // –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
    const connections = userConnections.get(user) || [];
    const connectionInfo = {
      target: target,
      url: req.url,
      method: req.method,
      timestamp: Date.now(),
      userAgent: req.get('user-agent') || 'unknown'
    };
    
    connections.push(connectionInfo);
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º—ã—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
    if (connections.length > 100) {
      connections.splice(0, connections.length - 100);
    }
    
    userConnections.set(user, connections);
    
    console.log(`üåê PROXY ${user}: ${req.method} ${req.url} -> ${target}`);
    
    return target;
  },
  
  onProxyReq: (proxyReq, req, res) => {
    const user = authenticate(req.headers['authorization']);
    if (user) {
      const proxy = getCurrentProxy(user);
      if (proxy) {
        const auth = Buffer.from(`${proxy.user}:${proxy.pass}`).toString('base64');
        proxyReq.setHeader('Proxy-Authorization', `Basic ${auth}`);
      }
    }
  },
  
  onError: (err, req, res) => {
    const user = authenticate(req.headers['authorization']) || 'unknown';
    console.error(`‚ùå PROXY ERROR for ${user}:`, err.message);
    
    if (!res.headersSent) {
      res.status(502).json({
        error: 'Proxy error',
        message: err.message,
        timestamp: new Date().toISOString()
      });
    }
  }
});

// –ü—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–æ–∫—Å–∏ middleware –∫–æ –≤—Å–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–º –∑–∞–ø—Ä–æ—Å–∞–º
app.use('/', (req, res, next) => {
  // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º API endpoints
  if (req.path.startsWith('/current') || 
      req.path.startsWith('/rotate') || 
      req.path.startsWith('/status') ||
      req.path.startsWith('/reset-cooldown') ||
      req.path.startsWith('/api/')) {
    return next();
  }
  
  // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–æ–∫—Å–∏
  proxyMiddleware(req, res, next);
});

// ===== ERROR HANDLING =====
app.use((err, req, res, next) => {
  console.error('Server error:', err.message);
  if (!res.headersSent) {
    res.status(500).json({
      error: 'Internal server error',
      message: err.message,
      timestamp: new Date().toISOString()
    });
  }
});

// ===== SERVER START =====
const server = app.listen(PORT, '0.0.0.0', async () => {
  console.log(`üöÄ Dynamic proxy server started on port ${PORT}`);
  console.log(`üîí Rotation cooldown: ${ROTATION_COOLDOWN_MS / 1000} seconds`);
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–∫—Å–∏
  await initializeProxies();
  
  console.log(`üìä Available proxies: ${proxyList.length}`);
  console.log(`üåê Server ready to accept connections`);
  
  if (process.env.ADMIN_API_KEY) {
    console.log(`üîë Admin API enabled for proxy management`);
  } else {
    console.log(`‚ö†Ô∏è ADMIN_API_KEY not set - proxy management API disabled`);
  }
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('üõë SIGTERM received, shutting down gracefully');
  server.close(() => {
    console.log('‚úÖ Server closed');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('üõë SIGINT received, shutting down gracefully');
  server.close(() => {
    console.log('‚úÖ Server closed');
    process.exit(0);
  });
});

module.exports = app;
